The base means for concurrency are is the java.lang.Thread class.
A Thread executes an object of type java.lang.Runnable

Runnable is an interface which defines the run() method. This method is called
by the Thread object and contains the work which should be done. Therefore the
"Runnable" is the task to perform. The Thread is the worker who is doing
this task.

Process is a separate unit of work. It cant interact directly with other processes.
It shares data only via operation system. There are situations when process is quite
free, but it can't share this free memory with other processes. Thread can do this.
Thread is a 'lightweight' process. By default java application runs in single process
- thread. But you can adjust the application in order to optimize the memory usage.
Threads can share objects between each other. Tasks are devided into small subtasks
and could be performed in parallel.

Threads have their own call stack, but can also access shared data.
Therefore you have two basic problems, visibility and access problems.

A visibility problem occurs if thread A reads shared data which is later changed
by thread B and thread A is unaware of this change.

An access problem can occur if several thread access and change the same shared data
at the same time. Java provides locks to protect certain parts of the code to be
executed by several threads at the same time. The simplest way of locking a certain
method or Java class is to define the method or class with the synchronized
keyword.

The synchronized keyword in Java ensures:

    that only a single thread can execute a block of code at the same time

    that each thread entering a synchronized block of code sees the effects
    of all previous modifications that were guarded by the same lock

Synchronization is necessary for mutually exclusive access to blocks of and for
reliable communication between threads.

You can use the synchronized keyword for the definition of a method.
This would ensure that only one thread can enter this method at the same time.
Another threads which is calling this method would wait until the first threads
leaves this method.

public synchronized void critial() {
  // some thread critical stuff
  // here
}


You can also use the synchronized keyword to protect blocks of code within a method.
This block is guarded by a key, which can be either a string or an object.
This key is called the lock. All code which is protected by the same lock
can only be executed by one thread at the same time.

Volatile

If a variable is declared with the volatile keyword then it is guaranteed that
any thread that reads the field will see the most recently written value.
The volatile keyword will not perform any mutual exclusive lock on the variable.
All fields are cached in thread. In order to get actual data
(directly from register of memory) we use volatile.

Atomic operation

An atomic operation is an operation which is performed as a single unit of work
without the possibility of interference from other operations.


 The i++ operation first reads the value which is currently stored in i
 (atomic operations) and then it adds one to it  (atomic operation).
 But between the read and the write the value of i might have changed.

Since Java 1.5 the java language provides atomic variables, e.g. AtomicInteger
or AtomicLong which provide methods like getAndDecrement(), getAndIncrement()
and getAndSet() which are atomic.

The Java memory model guarantees that each thread entering a synchronized block of
code sees the effects of all previous modifications that were guarded by the same lock.


For all mutable fields, e.g. Arrays, that are passed from the outside to the
class during the construction phase, the class needs to make a defensive-copy
of the elements to make sure that no other object from the outside still
can change the data


Defensive Copies

You must protected your classes from calling code. Assume that calling
code will do its best to change your data in  way you didn't expect it.
While this is especially true in case of immutable data it is also true
for non-immutable data which you still not expect that this data is
changed outside your class.

To protect your class against that you should copy data you receive and
only return copies of data to calling code.



Threads pools with the Executor Framework

Thread pools manage a pool of worker threads. The thread pools contains
a work queue which holds tasks waiting to get executed.

A thread pool can be described as a collection of Runnable objects (work queue)
and a connections of running threads.

These threads are constantly running and are checking the work query for new work.
If there is new work to be done they execute this Runnable. The Thread class itself
provides a method, e.g. execute(Runnable r) to add a new Runnable object
to the work queue.


Futures and Callables

 In case you expect your threads to return a computed result you can use
 java.util.concurrent.Callable.
 The Callable object allows to return values after completion.

The Callable object uses generics to define the type of object which is returned.


Deadlock

A concurrent application has the risk of a deadlock. A set of processes are
deadlocked if all processes are waiting for an event which another process
in the same set has to cause.

For example if thread A waits for a lock on object Z which thread B holds and
thread B wait for a look on object Y which is hold be process A then these two
processes are looked and cannot continue in their processing.

When working with Threads, it’s also possible to change the priority of a Thread.
In the Java Virtual Machine, the Thread scheduler, use a priority-based scheduling.
So if a Thread enter in Runnable state with a higher priority
than the running Thread, the new Thread will run and the current running
thread will be returned to Runnable state and waits for its turn. But this
behavior is not guaranteed and is completely depending on the virtual machine
you are working on.
So, do not rely on thread priorities, just use them to improve efficiency of your program.

 If you don’t specify a priority, the used priority, will be the priority of
 the current Thread.
 With help of yield() static method you can give an oppotunity to other threads to run.
 (you turn current thread to Runnable (waiting for run) state). Also if you don't
 set a priority, the priority of current therad will be set to new  thread.
 But in practise you don't have to rely on priorities. They really unpredictable.



 Thread lifecycle:

- !New! is the thread state for a thread which was created but has not yet started.
- !Ready!. Thread scheduling decides when the thread could actually start
- A thread in the !runnable! state is executing from the JVM point of view but in
fact it may be waiting for some resources from the operating system.
- !Timed waiting! is a thread state for a thread waiting with a specified waiting time.
A thread is in the timed waiting state due to calling one of the following methods with
a specified positive waiting time:


    Thread.sleep(sleeptime)
    Object.wait(timeout)
    Thread.join(timeout)
    LockSupport.parkNanos(timeout)
    LockSupport.parkUntil(timeout)

- A thread is in the !waiting! state due to the calling one of the following
methods without timeout:


    Object.wait()
    Thread.join()
    LockSupport.park()


Note, that thread in the waiting state is waiting for another thread to perform
a particular action. For example, a thread that has called Object.wait() on
an object is waiting for another thread to call Object.notify() or Object.notifyAll()
on that object.

- Thread is in the !blocked! state while waiting for the monitor lock to enter a
synchronized block or method or to reenter a synchronized block or method after
calling Object.wait().

